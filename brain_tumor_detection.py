# -*- coding: utf-8 -*-
"""Brain tumor detection

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OizbGfXBKdkPRtPvQBRKfs2k6XyV6vc1
"""

import zipfile
import os

# Define paths
zip_path = "/content/Brain_MRI_Images (1).zip"  # Update this with your ZIP file path
extract_path = "Brain_MRI_Images"  # Update this with your desired extraction folder

# Extract the dataset
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

# List the extracted files and folders
print("Extracted files:", os.listdir(extract_path))

import os
import numpy as np
import cv2

# Define image size
IMG_SIZE = 128

# Function to load and preprocess images
def load_data(data_path, categories):
    images = []
    labels = []

    for label, category in enumerate(categories):
        category_path = os.path.join(data_path, category)
        for img_name in os.listdir(category_path):
            img_path = os.path.join(category_path, img_name)
            img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)  # Read in grayscale
            img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))  # Resize
            images.append(img)
            labels.append(label)

    images = np.array(images) / 255.0  # Normalize
    images = np.expand_dims(images, axis=-1)  # Add channel dimension
    labels = np.array(labels)

    return images, labels

# Paths to dataset
dataset_root = "/content/Brain_MRI_Images/Brain MRI Images"
train_path = os.path.join(dataset_root, "Train")
validation_path = os.path.join(dataset_root, "Validation")

# Get class labels
train_classes = os.listdir(train_path)
validation_classes = os.listdir(validation_path)

# Load training and validation data
X_train, y_train = load_data(train_path, train_classes)
X_val, y_val = load_data(validation_path, validation_classes)

# Print data shapes
print("Training data shape:", X_train.shape)
print("Validation data shape:", X_val.shape)

from tensorflow.keras.utils import to_categorical

# Convert labels to categorical format (one-hot encoding)
y_train = to_categorical(y_train, num_classes=2)
y_val = to_categorical(y_val, num_classes=2)

# Print label shape
print("Training labels shape:", y_train.shape)
print("Validation labels shape:", y_val.shape)

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

# Define CNN model
model = keras.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 1)),
    layers.MaxPooling2D((2, 2)),

    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),

    layers.Conv2D(128, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),

    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dropout(0.5),  # Regularization
    layers.Dense(2, activation='softmax')  # 2 classes: Normal, Tumor
])

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Print model summary
model.summary()

# Train the model
history = model.fit(
    X_train, y_train,
    epochs=10,  # You can increase epochs for better accuracy
    validation_data=(X_val, y_val),
    batch_size=16  # Adjust batch size based on your system memory
)

# Save the trained model
model.save("brain_mri_tumor_model.h5")

# Print training completion message
print("Model training completed and saved as 'brain_mri_tumor_model.h5'")

# Evaluate the model
test_loss, test_acc = model.evaluate(X_val, y_val)
print(f"Validation Accuracy: {test_acc * 100:.2f}%")

import cv2
import numpy as np
import tensorflow as tf

# Load the trained model
model = tf.keras.models.load_model("brain_mri_tumor_model.h5")
model.compile(optimizer="adam", loss="categorical_crossentropy", metrics=["accuracy"])

def predict_mri(image_path, model):
    IMG_SIZE = 128
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)  # Read image in grayscale

    if img is None:
        print("Error: Unable to load image. Please check the file path.")
        return "Invalid Image"

    img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))  # Resize
    img = np.array(img, dtype=np.float32) / 255.0  # Normalize
    img = np.expand_dims(img, axis=-1)  # Add channel dimension (128, 128, 1)
    img = np.expand_dims(img, axis=0)   # Add batch dimension (1, 128, 128, 1)

    prediction = model.predict(img)

    # Debugging: Print raw model output
    print(f"Raw Model Output: {prediction}")

    predicted_class = np.argmax(prediction)

    # Debugging: Print predicted index
    print(f"Predicted Index: {predicted_class}")

    # Adjust labels based on dataset order
    class_label = "Tumor Detected" if predicted_class == 0 else "No Tumor Detected"

    return class_label

# Ask user to input file path
file_path = input("Enter the full path of the MRI scan image: ")

if file_path:
    result = predict_mri(file_path, model)
    print(f"Prediction: {result}")
else:
    print("No file selected.")